From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: deepak1556 <hop2deep@gmail.com>
Date: Mon, 23 May 2022 20:51:41 +0900
Subject: [sandbox] Disallow ArrayBuffers outside the VM Cage

Refs https://chromium-review.googlesource.com/c/v8/v8/+/3114136

diff --git a/src/js_native_api.h b/src/js_native_api.h
index 50ccf11e2405802f1c48764067b4010e8b9a0815..9fc02a744a60969a25fb8740236815ba8387bca5 100644
--- a/src/js_native_api.h
+++ b/src/js_native_api.h
@@ -310,11 +310,13 @@ NAPI_EXTERN napi_status napi_unwrap(napi_env env,
 NAPI_EXTERN napi_status napi_remove_wrap(napi_env env,
                                          napi_value js_object,
                                          void** result);
+#if !defined(V8_SANDBOX)
 NAPI_EXTERN napi_status napi_create_external(napi_env env,
                                              void* data,
                                              napi_finalize finalize_cb,
                                              void* finalize_hint,
                                              napi_value* result);
+#endif
 NAPI_EXTERN napi_status napi_get_value_external(napi_env env,
                                                 napi_value value,
                                                 void** result);
@@ -404,6 +406,7 @@ NAPI_EXTERN napi_status napi_create_arraybuffer(napi_env env,
                                                 size_t byte_length,
                                                 void** data,
                                                 napi_value* result);
+#if !defined(V8_SANDBOX)
 NAPI_EXTERN napi_status
 napi_create_external_arraybuffer(napi_env env,
                                  void* external_data,
@@ -411,6 +414,7 @@ napi_create_external_arraybuffer(napi_env env,
                                  napi_finalize finalize_cb,
                                  void* finalize_hint,
                                  napi_value* result);
+#endif
 NAPI_EXTERN napi_status napi_get_arraybuffer_info(napi_env env,
                                                   napi_value arraybuffer,
                                                   void** data,
diff --git a/src/js_native_api_v8.cc b/src/js_native_api_v8.cc
index 1c29c43836a0c35a832e494f8eaebbbe1eee8ea4..6ae5dd86436b85c107d879eaef33dd88ebb59a1c 100644
--- a/src/js_native_api_v8.cc
+++ b/src/js_native_api_v8.cc
@@ -2806,6 +2806,7 @@ napi_status napi_create_arraybuffer(napi_env env,
   return GET_RETURN_STATUS(env);
 }
 
+#if !defined(V8_SANDBOX)
 napi_status napi_create_external_arraybuffer(napi_env env,
                                              void* external_data,
                                              size_t byte_length,
@@ -2832,6 +2833,7 @@ napi_status napi_create_external_arraybuffer(napi_env env,
       result,
       nullptr);
 }
+#endif
 
 napi_status napi_get_arraybuffer_info(napi_env env,
                                       napi_value arraybuffer,
diff --git a/src/node_api.cc b/src/node_api.cc
index 60fbe96b8ef272768736ce029bac3ff72f3c84a5..c84e6e4d8b079dc82db26a3ec7fc96a018d15326 100644
--- a/src/node_api.cc
+++ b/src/node_api.cc
@@ -920,6 +920,7 @@ napi_status napi_create_buffer(napi_env env,
   return GET_RETURN_STATUS(env);
 }
 
+#if !defined(V8_SANDBOX)
 napi_status napi_create_external_buffer(napi_env env,
                                         size_t length,
                                         void* data,
@@ -952,6 +953,7 @@ napi_status napi_create_external_buffer(napi_env env,
   // is finalized.
   // coverity[leaked_storage]
 }
+#endif
 
 napi_status napi_create_buffer_copy(napi_env env,
                                     size_t length,
diff --git a/src/node_api.h b/src/node_api.h
index 1772c67c15afb2d2712b1900a584f627852e3d7e..eb5093534c9bc54916dcee1c5a014230adeab491 100644
--- a/src/node_api.h
+++ b/src/node_api.h
@@ -138,12 +138,14 @@ NAPI_EXTERN napi_status napi_create_buffer(napi_env env,
                                            size_t length,
                                            void** data,
                                            napi_value* result);
+#if !defined(V8_SANDBOX)
 NAPI_EXTERN napi_status napi_create_external_buffer(napi_env env,
                                                     size_t length,
                                                     void* data,
                                                     napi_finalize finalize_cb,
                                                     void* finalize_hint,
                                                     napi_value* result);
+#endif
 NAPI_EXTERN napi_status napi_create_buffer_copy(napi_env env,
                                                 size_t length,
                                                 const void* data,
diff --git a/src/node_buffer.cc b/src/node_buffer.cc
index 215bd8003aabe17e43ac780c723cfe971b437eae..dfbc3bc59fc57b2837ae7abe8f0353afc69ac5a1 100644
--- a/src/node_buffer.cc
+++ b/src/node_buffer.cc
@@ -77,6 +77,7 @@ using v8::Value;
 
 namespace {
 
+#if !defined(V8_SANDBOX)
 class CallbackInfo {
  public:
   static inline Local<ArrayBuffer> CreateTrackedArrayBuffer(
@@ -199,6 +200,7 @@ void CallbackInfo::OnBackingStoreFree() {
     self->CallAndResetCallback();
   });
 }
+#endif
 
 
 // Parse index for external array data. An empty Maybe indicates
@@ -424,7 +426,7 @@ MaybeLocal<Object> Copy(Environment* env, const char* data, size_t length) {
   return scope.EscapeMaybe(obj);
 }
 
-
+#if !defined(V8_SANDBOX)
 MaybeLocal<Object> New(Isolate* isolate,
                        char* data,
                        size_t length,
@@ -505,6 +507,7 @@ MaybeLocal<Object> New(Environment* env,
   auto free_callback = [](char* data, void* hint) { free(data); };
   return New(env, data, length, free_callback, nullptr);
 }
+#endif
 
 namespace {
 
diff --git a/src/node_buffer.h b/src/node_buffer.h
index 606a6f5caa3b11b6d2a9068ed2fd65800530a5eb..ae19f608e7c1de6f537658fa12d4c0566e7e7fb1 100644
--- a/src/node_buffer.h
+++ b/src/node_buffer.h
@@ -31,7 +31,9 @@ namespace Buffer {
 
 static const size_t kMaxLength = v8::TypedArray::kMaxLength;
 
+#if !defined(V8_SANDBOX)
 typedef void (*FreeCallback)(char* data, void* hint);
+#endif
 
 NODE_EXTERN bool HasInstance(v8::Local<v8::Value> val);
 NODE_EXTERN bool HasInstance(v8::Local<v8::Object> val);
@@ -53,6 +55,7 @@ NODE_EXTERN v8::MaybeLocal<v8::Object> New(v8::Isolate* isolate,
                                            v8::Local<v8::String> string,
                                            enum encoding enc = UTF8);
 
+#if !defined(V8_SANDBOX)
 // public constructor - data is used, callback is passed data on object gc
 NODE_EXTERN v8::MaybeLocal<v8::Object> New(v8::Isolate* isolate,
                                            char* data,
@@ -64,6 +67,7 @@ NODE_EXTERN v8::MaybeLocal<v8::Object> New(v8::Isolate* isolate,
 NODE_EXTERN v8::MaybeLocal<v8::Object> New(v8::Isolate* isolate,
                                            char* data,
                                            size_t len);
+#endif
 
 // Creates a Buffer instance over an existing ArrayBuffer.
 NODE_EXTERN v8::MaybeLocal<v8::Uint8Array> New(v8::Isolate* isolate,
diff --git a/src/node_internals.h b/src/node_internals.h
index d37be23cd63e82d4040777bd0e17ed449ec0b15b..434493958768eae17073a967ba7de43942b1a653 100644
--- a/src/node_internals.h
+++ b/src/node_internals.h
@@ -140,6 +140,7 @@ class DebuggingArrayBufferAllocator final : public NodeArrayBufferAllocator {
 namespace Buffer {
 v8::MaybeLocal<v8::Object> Copy(Environment* env, const char* data, size_t len);
 v8::MaybeLocal<v8::Object> New(Environment* env, size_t size);
+#if !defined(V8_SANDBOX)
 // Takes ownership of |data|.
 v8::MaybeLocal<v8::Object> New(Environment* env,
                                char* data,
@@ -151,6 +152,7 @@ v8::MaybeLocal<v8::Object> New(Environment* env,
 v8::MaybeLocal<v8::Object> New(Environment* env,
                                char* data,
                                size_t length);
+#endif
 // Creates a Buffer instance over an existing ArrayBuffer.
 v8::MaybeLocal<v8::Uint8Array> New(Environment* env,
                                    v8::Local<v8::ArrayBuffer> ab,
@@ -171,9 +173,11 @@ static v8::MaybeLocal<v8::Object> New(Environment* env,
   char* src = reinterpret_cast<char*>(buf->out());
   const size_t len_in_bytes = buf->length() * sizeof(buf->out()[0]);
 
+#if !defined(V8_SANDBOX)
   if (buf->IsAllocated())
     ret = New(env, src, len_in_bytes);
   else if (!buf->IsInvalidated())
+#endif
     ret = Copy(env, src, len_in_bytes);
 
   if (ret.IsEmpty())
diff --git a/src/node_serdes.cc b/src/node_serdes.cc
index f6f0034bc24d09e3ad65491c7d6be0b9c9db1581..3a5dbb7bbacac81a34ed01959ae334849bae8c48 100644
--- a/src/node_serdes.cc
+++ b/src/node_serdes.cc
@@ -209,9 +209,16 @@ void SerializerContext::ReleaseBuffer(const FunctionCallbackInfo<Value>& args) {
   // Note: Both ValueSerializer and this Buffer::New() variant use malloc()
   // as the underlying allocator.
   std::pair<uint8_t*, size_t> ret = ctx->serializer_.Release();
+#if !defined(V8_SANDBOX)
   auto buf = Buffer::New(ctx->env(),
                          reinterpret_cast<char*>(ret.first),
                          ret.second);
+#else
+  auto buf = Buffer::Copy(ctx->env(),
+                          reinterpret_cast<char*>(ret.first),
+                          ret.second);
+  free(ret.first);
+#endif
 
   if (!buf.IsEmpty()) {
     args.GetReturnValue().Set(buf.ToLocalChecked());
diff --git a/src/node_worker.cc b/src/node_worker.cc
index a734d65965a9d77dd066bda828eb5878c1e6d9f5..a98deb6e3f77390c6167f8a4a0bf415d4664c0d7 100644
--- a/src/node_worker.cc
+++ b/src/node_worker.cc
@@ -54,6 +54,9 @@ Worker::Worker(Environment* env,
       per_isolate_opts_(per_isolate_opts),
       exec_argv_(exec_argv),
       platform_(env->isolate_data()->platform()),
+#if defined(V8_SANDBOX)
+      array_buffer_allocator_(env->isolate()->GetArrayBufferAllocator()),
+#endif
       thread_id_(AllocateEnvironmentThreadId()),
       env_vars_(env_vars) {
   Debug(this, "Creating new worker instance with thread id %llu",
@@ -140,11 +143,17 @@ class WorkerThreadData {
     loop_init_failed_ = false;
     uv_loop_configure(&loop_, UV_METRICS_IDLE_TIME);
 
+#if !defined(V8_SANDBOX)
     std::shared_ptr<ArrayBufferAllocator> allocator =
         ArrayBufferAllocator::Create();
+#endif
     Isolate::CreateParams params;
     SetIsolateCreateParamsForNode(&params);
+#if !defined(V8_SANDBOX)
     params.array_buffer_allocator_shared = allocator;
+#else
+    params.array_buffer_allocator = w->array_buffer_allocator_;
+#endif
 
     w->UpdateResourceConstraints(&params.constraints);
 
@@ -171,10 +180,16 @@ class WorkerThreadData {
       isolate->SetStackLimit(w->stack_base_);
 
       HandleScope handle_scope(isolate);
+#if !defined(V8_SANDBOX)
       isolate_data_.reset(CreateIsolateData(isolate,
                                             &loop_,
                                             w_->platform_,
                                             allocator.get()));
+#else
+      isolate_data_.reset(CreateIsolateData(isolate,
+                                            &loop_,
+                                            w_->platform_));
+#endif
       CHECK(isolate_data_);
       if (w_->per_isolate_opts_)
         isolate_data_->set_options(std::move(w_->per_isolate_opts_));
diff --git a/src/node_worker.h b/src/node_worker.h
index 077d2b8390e6f8b29957577ee5d31ea2e1827cb4..e79f3e94829c4664ab006d58d3fd1034db25d299 100644
--- a/src/node_worker.h
+++ b/src/node_worker.h
@@ -79,6 +79,9 @@ class Worker : public AsyncWrap {
   std::vector<std::string> argv_;
 
   MultiIsolatePlatform* platform_;
+#if defined(V8_SANDBOX)
+  v8::ArrayBuffer::Allocator* array_buffer_allocator_;
+#endif
   v8::Isolate* isolate_ = nullptr;
   uv_thread_t tid_;
 
