From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Thibaud Michaud <thibaudm@chromium.org>
Date: Fri, 21 Jun 2024 16:31:15 +0200
Subject: Fix scanning of wasm-to-js params

Wasm-to-js wrappers are sometimes compiled as on-heap Code objects, for
example when tiering-up from a WasmFuncRef call origin. The frames of
these functions are mapped to a subclass of TypedFrame, however
TypedFrame::Iterate() only supports iterating the generic wasm-to-js
wrapper.

Add support for iterating the tagged parameters of optimized wasm-to-js
wrappers in TypedFrame::Iterate. For this we also add two 16-bit fields
in the Code object to encode the incoming tagged parameter region, which
we would normally find in the WasmCode data.

R=jkummerow@chromium.org

Fixed: 346597059
Change-Id: I425619fca86c38f91f1ca9cbeb70e7b5a7b2d6c1
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/5639725
Reviewed-by: Jakob Kummerow <jkummerow@chromium.org>
Commit-Queue: Thibaud Michaud <thibaudm@chromium.org>
Cr-Commit-Position: refs/heads/main@{#94589}

diff --git a/src/compiler/pipeline.cc b/src/compiler/pipeline.cc
index aebfc45311722350a8c4d6cb2d73b343b33e90d1..55dcd318d8fed5e28caf0544e456f890f4ea3865 100644
--- a/src/compiler/pipeline.cc
+++ b/src/compiler/pipeline.cc
@@ -2196,6 +2196,39 @@ CompilationJob::Status FinalizeWrapperCompilation(
   }
   return CompilationJob::FAILED;
 }
+
+CompilationJob::Status FinalizeWrapperCompilation(
+    turboshaft::PipelineData* turboshaft_data, OptimizedCompilationInfo* info,
+    CallDescriptor* call_descriptor, Isolate* isolate,
+    const char* method_name) {
+  Handle<Code> code;
+  turboshaft::Pipeline pipeline(turboshaft_data);
+  if (!pipeline.FinalizeCode(call_descriptor).ToHandle(&code)) {
+    V8::FatalProcessOutOfMemory(isolate, method_name);
+  }
+  DCHECK_NULL(turboshaft_data->depedencies());
+  info->SetCode(code);
+#ifdef ENABLE_DISASSEMBLER
+  if (v8_flags.print_wasm_code) {
+    CodeTracer::StreamScope tracing_scope(isolate->GetCodeTracer());
+    code->Disassemble(info->GetDebugName().get(), tracing_scope.stream(),
+                      isolate);
+  }
+#endif
+
+  if (isolate->IsLoggingCodeCreation()) {
+    PROFILE(isolate, CodeCreateEvent(LogEventListener::CodeTag::kStub,
+                                     Cast<AbstractCode>(code),
+                                     info->GetDebugName().get()));
+  }
+  if (code->kind() == CodeKind::WASM_TO_JS_FUNCTION) {
+    code->set_wasm_js_tagged_parameter_count(
+        call_descriptor->GetTaggedParameterSlots() & 0xffff);
+    code->set_wasm_js_first_tagged_parameter(
+        call_descriptor->GetTaggedParameterSlots() >> 16);
+  }
+  return CompilationJob::SUCCEEDED;
+}
 }  // namespace
 
 CompilationJob::Status WasmHeapStubCompilationJob::ExecuteJobImpl(
diff --git a/src/objects/code.h b/src/objects/code.h
index 8191cc9f98abd96e8df41010baf0c3a967fb7872..764f256703136157636e482c00c81dc79ce58030 100644
--- a/src/objects/code.h
+++ b/src/objects/code.h
@@ -130,6 +130,7 @@ class Code : public ExposedTrustedObject {
   // out how to obtain the parameter count during code generation when no
   // BytecodeArray is available from which it can be copied.
   DECL_PRIMITIVE_ACCESSORS(parameter_count, uint16_t)
+  inline uint16_t parameter_count_without_receiver() const;
   DECL_PRIMITIVE_ACCESSORS(wasm_js_tagged_parameter_count, uint16_t)
   DECL_PRIMITIVE_ACCESSORS(wasm_js_first_tagged_parameter, uint16_t)
 
