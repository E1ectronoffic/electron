From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Raymond Zhao <raymondzhao@microsoft.com>
Date: Wed, 18 Aug 2021 08:24:10 -0700
Subject: Convert Electron ProcessSingleton changes to patch

This patch applies Electron ProcessSingleton changes
onto the Chromium files, so that Electron doesn't need to maintain
separate copies of those files.

This patch adds a few changes to the Chromium code:
1. It adds a parameter `program_name` to the constructor so that
   the generated mutex name on the Windows-side is program-dependent,
   rather than shared between all Electron applications.
2. It adds an `IsAppSandboxed` check to the posix side so that
   sandboxed posix applications generate shorter temp paths.
3. It adds a `ChangeWindowMessageFilterEx` call to the Windows
   implementation to handle the case when the primary app is run with
   admin permissions.

diff --git a/chrome/browser/process_singleton.h b/chrome/browser/process_singleton.h
index 0291db0f919aa7868d345f4f0712c42c6ad7ee17..1c34b939e85543aba6801c45ba81fe626aad65fe 100644
--- a/chrome/browser/process_singleton.h
+++ b/chrome/browser/process_singleton.h
@@ -103,7 +103,8 @@ class ProcessSingleton {
       base::RepeatingCallback<bool(const base::CommandLine& command_line,
                                    const base::FilePath& current_directory)>;
 
-  ProcessSingleton(const base::FilePath& user_data_dir,
+  ProcessSingleton(const std::string& program_name,
+                   const base::FilePath& user_data_dir,
                    const NotificationCallback& notification_callback);
   ~ProcessSingleton();
 
@@ -166,6 +167,7 @@ class ProcessSingleton {
 
  private:
   NotificationCallback notification_callback_;  // Handler for notifications.
+  std::string program_name_; // Used for kMutexName.
 
 #if defined(OS_WIN)
   bool EscapeVirtualization(const base::FilePath& user_data_dir);
diff --git a/chrome/browser/process_singleton_posix.cc b/chrome/browser/process_singleton_posix.cc
index dc9c1b76a1c7c8b3fa83fc83788eef36d2cfa4a5..c65419336ace0cf7b4a975ebb2d2307fefbe966d 100644
--- a/chrome/browser/process_singleton_posix.cc
+++ b/chrome/browser/process_singleton_posix.cc
@@ -348,6 +348,21 @@ bool CheckCookie(const base::FilePath& path, const base::FilePath& cookie) {
   return (cookie == ReadLink(path));
 }
 
+bool IsAppSandboxed() {
+#if defined(OS_MAC)
+  // NB: There is no sane API for this, we have to just guess by
+  // reading tea leaves
+  base::FilePath home_dir;
+  if (!base::PathService::Get(base::DIR_HOME, &home_dir)) {
+    return false;
+  }
+
+  return home_dir.value().find("Library/Containers") != std::string::npos;
+#else
+  return false;
+#endif  // defined(OS_MAC)
+}
+
 bool ConnectSocket(ScopedSocket* socket,
                    const base::FilePath& socket_path,
                    const base::FilePath& cookie_path) {
@@ -712,9 +727,11 @@ void ProcessSingleton::LinuxWatcher::SocketReader::FinishWithACK(
 // ProcessSingleton
 //
 ProcessSingleton::ProcessSingleton(
+    const std::string& program_name,
     const base::FilePath& user_data_dir,
     const NotificationCallback& notification_callback)
     : notification_callback_(notification_callback),
+      program_name_(program_name),
       current_pid_(base::GetCurrentProcId()),
       watcher_(new LinuxWatcher(this)) {
   socket_path_ = user_data_dir.Append(chrome::kSingletonSocketFilename);
@@ -997,12 +1014,26 @@ bool ProcessSingleton::Create() {
 #endif
   }
 
-  // Create the socket file somewhere in /tmp which is usually mounted as a
-  // normal filesystem. Some network filesystems (notably AFS) are screwy and
-  // do not support Unix domain sockets.
-  if (!socket_dir_.CreateUniqueTempDir()) {
-    LOG(ERROR) << "Failed to create socket directory.";
-    return false;
+  if (IsAppSandboxed()) {
+    // For sandboxed applications, the tmp dir could be too long to fit
+    // addr->sun_path, so we need to make it as short as possible.
+    base::FilePath tmp_dir;
+    if (!base::GetTempDir(&tmp_dir)) {
+      LOG(ERROR) << "Failed to get temporary directory.";
+      return false;
+    }
+    if (!socket_dir_.Set(tmp_dir.Append("S"))) {
+      LOG(ERROR) << "Failed to set socket directory.";
+      return false;
+    }
+  } else {
+    // Create the socket file somewhere in /tmp which is usually mounted as a
+    // normal filesystem. Some network filesystems (notably AFS) are screwy and
+    // do not support Unix domain sockets.
+    if (!socket_dir_.CreateUniqueTempDir()) {
+      LOG(ERROR) << "Failed to create socket directory.";
+      return false;
+    }
   }
 
   // Check that the directory was created with the correct permissions.
diff --git a/chrome/browser/process_singleton_win.cc b/chrome/browser/process_singleton_win.cc
index f1732f042c3bfd9d5d95a4208664f9252b2aab73..c7527b9339f59a2159e34c63f0e4452e447b7433 100644
--- a/chrome/browser/process_singleton_win.cc
+++ b/chrome/browser/process_singleton_win.cc
@@ -260,9 +260,11 @@ bool ProcessSingleton::EscapeVirtualization(
 }
 
 ProcessSingleton::ProcessSingleton(
+    const std::string& program_name,
     const base::FilePath& user_data_dir,
     const NotificationCallback& notification_callback)
     : notification_callback_(notification_callback),
+      program_name_(program_name),
       is_virtualized_(false),
       lock_file_(INVALID_HANDLE_VALUE),
       user_data_dir_(user_data_dir),
@@ -370,7 +372,7 @@ ProcessSingleton::NotifyOtherProcessOrCreate() {
 // isn't one, create a message window with its title set to the profile
 // directory path.
 bool ProcessSingleton::Create() {
-  static const wchar_t kMutexName[] = L"Local\\ChromeProcessSingletonStartup!";
+  std::wstring mutexName = base::UTF8ToWide("Local\\" + program_name_ + "ProcessSingletonStartup");
 
   remote_window_ = chrome::FindRunningChromeWindow(user_data_dir_);
   if (!remote_window_ && !EscapeVirtualization(user_data_dir_)) {
@@ -379,7 +381,7 @@ bool ProcessSingleton::Create() {
     // access. As documented, it's clearer to NOT request ownership on creation
     // since it isn't guaranteed we will get it. It is better to create it
     // without ownership and explicitly get the ownership afterward.
-    base::win::ScopedHandle only_me(::CreateMutex(NULL, FALSE, kMutexName));
+    base::win::ScopedHandle only_me(::CreateMutex(NULL, FALSE, mutexName.c_str()));
     if (!only_me.IsValid()) {
       DPLOG(FATAL) << "CreateMutex failed";
       return false;
@@ -418,6 +420,12 @@ bool ProcessSingleton::Create() {
             window_.CreateNamed(base::BindRepeating(&ProcessLaunchNotification,
                                                     notification_callback_),
                                 user_data_dir_.value());
+
+        // NB: Ensure that if the primary app gets started as elevated
+        // admin inadvertently, secondary windows running not as elevated
+        // will still be able to send messages
+        ::ChangeWindowMessageFilterEx(window_.hwnd(), WM_COPYDATA, MSGFLT_ALLOW,
+                                      NULL);
         CHECK(result && window_.hwnd());
       }
     }
