From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: deepak1556 <hop2deep@gmail.com>
Date: Mon, 3 Jun 2019 14:20:05 -0700
Subject: frame_host_manager.patch

Allows embedder to intercept site instances chosen by chromium
and respond with custom instance. Also allows for us to at-runtime
enable or disable this patch.

diff --git a/content/browser/browsing_instance.cc b/content/browser/browsing_instance.cc
index 30e374aeba7aceacdb58add9c79cb46c6b93af4d..3e34643c4e1d5561c6c7b01e3de8cdd46910afb0 100644
--- a/content/browser/browsing_instance.cc
+++ b/content/browser/browsing_instance.cc
@@ -61,6 +61,13 @@ scoped_refptr<SiteInstanceImpl> BrowsingInstance::GetSiteInstanceForURL(
   return instance;
 }
 
+scoped_refptr<SiteInstanceImpl> BrowsingInstance::CreateSiteInstanceForURL(
+    const GURL& url) {
+  scoped_refptr<SiteInstanceImpl> instance = new SiteInstanceImpl(this);
+  instance->SetSite(UrlInfo(url, UrlInfo::OriginIsolationRequest::kNone));
+  return instance;
+}
+
 SiteInfo BrowsingInstance::GetSiteInfoForURL(const UrlInfo& url_info,
                                              bool allow_default_instance) {
   scoped_refptr<SiteInstanceImpl> site_instance =
diff --git a/content/browser/browsing_instance.h b/content/browser/browsing_instance.h
index f426d1ebdaa9d13c7e47f22ce617e2b61a862854..26907541dd4268e3f8c82676bdda892bd1ed04e7 100644
--- a/content/browser/browsing_instance.h
+++ b/content/browser/browsing_instance.h
@@ -151,6 +151,11 @@ class CONTENT_EXPORT BrowsingInstance final
       const UrlInfo& url_info,
       bool allow_default_instance);
 
+  // Create a new SiteInstance for the given URL bound the current
+  // BrowsingInstance.
+  scoped_refptr<SiteInstanceImpl> CreateSiteInstanceForURL(
+      const GURL& url);
+
   // Adds the given SiteInstance to our map, to ensure that we do not create
   // another SiteInstance for the same site.
   void RegisterSiteInstance(SiteInstanceImpl* site_instance);
diff --git a/content/browser/renderer_host/navigation_request.cc b/content/browser/renderer_host/navigation_request.cc
index 1f0b01cbf17267bd8c03deb4a28938566f7033ef..5ccf84c2b847e9d2cbc97f4b2390220324a807c3 100644
--- a/content/browser/renderer_host/navigation_request.cc
+++ b/content/browser/renderer_host/navigation_request.cc
@@ -1572,6 +1572,21 @@ void NavigationRequest::BeginNavigation() {
     if (IsSameDocument()) {
       render_frame_host_ = frame_tree_node_->current_frame_host();
     } else {
+      // In Electron, a new process is started for every navigation when node is
+      // integrated in the renderer. Since GetFrameHostForNavigation is called more
+      // than once per navigation, we want to return the same frame host once
+      // the response has started, otherwise if the frame host that started the response
+      // and the frame host that is available for commit don't match then request will
+      // be cancelled. We rely on the NavigationRequest::state_ to determine this
+      // factor
+      //
+      // bool has_response_started =
+      //    (request->state() >= NavigationRequest::WILL_PROCESS_RESPONSE &&
+      //     !speculative_render_frame_host_);
+      //
+      // Hence this call is necesary before the call to GetFrameHostForNavigation.
+      SetState(REUSE_SITE_INSTANCE);
+
       // Select an appropriate RenderFrameHost.
       std::string frame_host_choice_reason;
       render_frame_host_ =
@@ -6152,6 +6167,7 @@ void NavigationRequest::CheckStateTransition(NavigationState state) const {
           {WILL_START_REQUEST, {
               WILL_REDIRECT_REQUEST,
               WILL_PROCESS_RESPONSE,
+              REUSE_SITE_INSTANCE,
               READY_TO_COMMIT,
               DID_COMMIT,
               CANCELING,
@@ -6165,10 +6181,15 @@ void NavigationRequest::CheckStateTransition(NavigationState state) const {
               WILL_FAIL_REQUEST,
           }},
           {WILL_PROCESS_RESPONSE, {
+              REUSE_SITE_INSTANCE,
               READY_TO_COMMIT,
               CANCELING,
               WILL_FAIL_REQUEST,
           }},
+          {REUSE_SITE_INSTANCE, {
+              WILL_PROCESS_RESPONSE,
+              READY_TO_COMMIT,
+          }},
           {READY_TO_COMMIT, {
               NOT_STARTED,
               DID_COMMIT,
diff --git a/content/browser/renderer_host/navigation_request.h b/content/browser/renderer_host/navigation_request.h
index 304de734c34efd3c4f6ab561d66ecf7d655387f8..6817bfd0ea8934b2b1a1d62415b5475d5c88d20b 100644
--- a/content/browser/renderer_host/navigation_request.h
+++ b/content/browser/renderer_host/navigation_request.h
@@ -140,6 +140,10 @@ class CONTENT_EXPORT NavigationRequest
     // asynchronous.
     WILL_PROCESS_RESPONSE,
 
+    // Electron: state that is between than WILL_PROCESS_RESPONSE and
+    // READY_TO_COMMIT to force reuse the same site instance.
+    REUSE_SITE_INSTANCE,
+
     // The response started on the IO thread and is ready to be committed.
     READY_TO_COMMIT,
 
diff --git a/content/browser/renderer_host/render_frame_host_manager.cc b/content/browser/renderer_host/render_frame_host_manager.cc
index af497e6916d72bfbd40fe9f131be6022482ef810..6b241fad6ef19250ef2fe47403c5edcb402c70ca 100644
--- a/content/browser/renderer_host/render_frame_host_manager.cc
+++ b/content/browser/renderer_host/render_frame_host_manager.cc
@@ -2859,6 +2859,16 @@ scoped_refptr<SiteInstance>
 RenderFrameHostManager::GetSiteInstanceForNavigationRequest(
     NavigationRequest* request,
     std::string* reason) {
+  // Compute the SiteInstance that the navigation should use, which will be
+  // either the current SiteInstance or a new one.
+  //
+  // TODO(clamy): We should also consider as a candidate SiteInstance the
+  // speculative SiteInstance that was computed on redirects.
+  SiteInstanceImpl* candidate_site_instance =
+      speculative_render_frame_host_
+          ? speculative_render_frame_host_->GetSiteInstance()
+          : nullptr;
+
   SiteInstance* current_site_instance = render_frame_host_->GetSiteInstance();
 
   // All children of MHTML documents must be MHTML documents. They all live in
@@ -2922,6 +2932,9 @@ RenderFrameHostManager::GetSiteInstanceForNavigationRequest(
     request->ResetStateForSiteInstanceChange();
   }
 
+  GetContentClient()->browser()->RegisterPendingSiteInstance(
+      render_frame_host_.get(), dest_site_instance.get());
+
   return dest_site_instance;
 }
 
diff --git a/content/public/browser/content_browser_client.h b/content/public/browser/content_browser_client.h
index 47befa844ca54f463b627864827aa670454dfed4..1a27f50e5922c3886816e7523dda98e1d7a87bda 100644
--- a/content/public/browser/content_browser_client.h
+++ b/content/public/browser/content_browser_client.h
@@ -263,6 +263,11 @@ class CONTENT_EXPORT ContentBrowserClient {
 
   virtual ~ContentBrowserClient() = default;
 
+  // Electron: Registers a pending site instance during a navigation.
+  virtual void RegisterPendingSiteInstance(
+      content::RenderFrameHost* rfh,
+      content::SiteInstance* pending_site_instance) {}
+
   // Allows the embedder to set any number of custom BrowserMainParts
   // implementations for the browser startup code. See comments in
   // browser_main_parts.h.
